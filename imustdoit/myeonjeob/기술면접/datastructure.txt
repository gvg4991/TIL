자료구조

Array
 . index로 해당 원소 접근가능 (bigO(1))
 . 삭제/삽입 과정에서 배열의 연속성이 깨지므로 shift 필요 (bigO(n))

Linked List
 . 각 원소들이 자신 다음에 어떤 원소인지만 기억
 . 삭제/삽입 작업을 다음 원소 기억만 바꿔주면 되나 해당 원소를 찾아야 됨 (bigO(n))
 . 원하는 위치를 찾을 때 search 과정 필요 (bigO(n))



=======================================


Stack
 . 선형 자료구조로 LIFO(마지막 원소가 가장 먼저 나옴)

Queue
 . 선형 자료구조로 FIFO(먼저 들어간 원소가 가장 먼저 나옴)
 . 첫원소 front, 끝원소 rear


========================================


Tree
 . 비선형 자료구조, 계층적 관계를 표현, 트리는 노드로 이루어진 자료 구조
1) node(노드) : 트리를 구성하는 각 요소
2) Edge(간선) : 노드-노드를 연결하는 선
3) Root(루트 노드) : 트리 구조에서 최상위 노드
4) Terminal(단말 노드) : 하위에 다른 노드가 없는 노드
5) Internal(내부 노드) : 단말 노드 제외한 모든 노드(루트노드 포함)

Binary Tree(이진트리)
 . 루트 노드를 중심으로 두개의 서브트리로 나뉨
 . 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼
 . 공집합도 이진 트리로 포함
1) 포화 이진트리 (perfect) : 모든 레벨이 꽉 참
2) 완전 이진트리 (Complete) : 순서대로 채워진 이진트리
3) 정 이진트리 (Full) : 모든 노드가 0이나 2개 자식 노드 가짐

# tree
# 전위순회 = 루트 - 레프트 - 라이트 (프리)
# 중위순회 = 레프트 - 루트 - 라이트 (인)
# 후위순회 = 레프트 - 라이트 - 루트 (포스터)




========================================



그래프
 . 노드와 노드를 연결하는 간선을 하나로 모아둔 자료구조
 . 사이클 가능
 . 그래프에 따라 간선 수가 다름



========================================


heap
 . 완전 이진트리에 가까운 형태
 . 
1) 최대 힙 : 부모노드의 값 >= 자식노드의 값
2) 최소 힙 : 부모노드의 값 <= 자식노드의 값
 . 삽입 : 일단 마지막 노드에 삽입 후 부모노드와 교환


========================================



해시(hash)
 . 임의 길이 데이터를 고정된 길이로 매핑
 . 적은 자원으로 많은 데이터 효율적 관리
 . 해시 함수를 통해 해시테이블에 넣음(키,벨류)
   


========================================


B Tree
 . 이진트리 확장, 더많은 수의 자식을 가짐
 . 트리 균형을 자동으로 맞춤

1) B-tree
 . 각 노드에 데이터 저장
 . 
2) B+tree


========================================



DFS (깊이 우선 탐색)
 . 한 정점에서 한정점으로만 나아간다

BFS (너비 우선 탐색)
 . 한 정점으로부터 연결된 모든 정점으로 나아간다


