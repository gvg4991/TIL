데이타베이스

특징
1) 데이터 독립성
 . 데이터베이스 사이즈 늘리거나 파일을 새로게 추가하더라고 응용프로그램을 수정할 필요 없음
2) 데이터 무결성
 . 데이터 유효성 검사를 통해 잘못된 데이터 발생을 방지
3) 데이터 보안성
 . 인가된 사용자만 DB나 DB자원에 접근할 수 있도록 계정 관리하여 보안설정
4) 데이터 일관성 (정합성)
 . 연관된 정보를 논리적 구조로 관리, 하나의 뎅터만 변경했을 때 발생하는 데이터 불일치성을 배제
5) 중복 최소화
 . 데이터를 통합해서 관리함으로써 파일 시스템의 단점인 데이터 중복성 문제 해결


==========================================



데이터베이스 풀
- connection
 . 클라이언트의 요청으로 어플리케이션 스레드에서 DB에 접근
 . connection pool : connection을 여러개 생성해서 저장한 공간(캐시)

- DB 접근 단계
 . DB에 요청 시 pool에서 connection 객체를 가져와 접근
 . 풀에서 커넥션 가져옴 > 커넥션 사용 > 커넥션 반환
 . connection이 부족하면 해당 클라이언트 대기 상태로 전환

- 장점
 . 매 연결마다 connection 객체를 생성/소멸할 필요 없음
 . 비용 및 DB접근 시간 단축
 . 메모리와 DB에 걸리는 부하 조정 가능


============================================

thread pool
 . WAS에서 thread를 통해 요청을 보냄
 . 모든 요청이 DB접근이 아니므로 thread수 > connection수가 좋음


===========================================

트랜잭션
 . DB의 상태를 변환시키는 논리적인 작업 단위
 . 하나의 트랙잭션이 commit되거나 rollback됨
 . 예기치 않은 상황이 발생하거나 데이터를 덮어쓰는 경우를 방지하기 위해 사용
- commit 연산
 . 트랜잭션 작업이 성공저긍로 끝나 DB가 다시 일관된 상태
 . 트랜잭션이 행한 연산이 갱신됨
- rollback 연산
 . 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성이 깨짐
 . 트랜잭션이 행한 연산을 취소

ACID(트랜잭션의 성질)
1) 원자성 (Atomicity)
 . 트랜잭션의 연산은 정상적으로 완료되거나 어떠한 연산도 수행되지 않은 상태 보장
2) 일관성 (Consistency)
 . 트랜잭션 후 DB 일관된 상태 유지
3) 독립성 (Isolation)
 . 트랜잭션 실행 중 변경된 데이터는 트랜잭션 완료까지 다른 트랜잭션이 참조 못함
 . Locking을 통해 다른 트랜잭션이 관여하지 못하게 막음
4) 지속성 (Durability)
 . 성공한 트랜잭션은 영원히 반영됨



============================================


relationship (관계)
 . 정규화를 수행하면 의미있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리 관계(relationship)를 갖게됨
 . 저장공간의 효율성과 확장성이 향상

join
 . 둘 이상의 테이블간 논리적 관계를 기준으로 데이터를 연결하여 결과 집합을 만드는 연산
 . 두개 이상의 테이블이나 DB를 연결하여 데이터 검색
 . 한 DB 내 여러 테이블의 레코드를 조합하여 하나의 열로 표현
 . 여러 테이블로 나뉜 relationship 데이터를 효과적으로 검색

- 내부조인 (inner조인)
 . 두 테이블간에 공통으로 포함되어 있는 값을 결과 집합으로 만듬
 . 기본 조인 형식으로 새로운 결과 테이블 생성
 . 명시적 조인 표현 : from A inner join B
 . 암식적 조인 : from A,B (교차조인)
1) 동등조인 (EQUI JOIN)
 . 비교자 기반의 조인으로 동등비교 ('='만 가능)
2) 자연조인 (NATURAL JOIN)
 . 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교
 . 결과적으로 조인된 테이블은 하나의 컬럼만 포함
3) 교차조인 (CROSS JOIN)
 . 조인되는 두 테이블의 곱집합을 반환
 . m행 테이블과 n행 테이블이 교차조인하면 m*n개 행 생성

- 외부조인 (outer조인)
 . 한 테이블에만 데이터가 있더라도 값을 가져와 집합으로 만듬
 . 특정 테이블의 데이터가 모두 필요한 상황에서 활용
1) 왼쪽 외부조인 (LEFT OUTER JOIN)
 . 우측 테이블에 조인할 컬럼의 값이 없는 경우 사용
 . 좌측 테이블의 모든 데이터를 포함하는 결과 생성
2) 오른쪽 외부조인 (RIGHT OUTER JOIN)
 . 좌측 테이블에 조인할 컬럼의 값이 없는 경우 사용
 . 우측 테이블의 모든 데이터를 포함하는 결과 생성
3) 완전 외부조인 (FULL OUTER TABLE)
 . 조인되는 두 테이블의 합집합을 반환
 . 양쪽 테이블 모두 outer join이 필요할때 사용

- 셀프조인
 . 한 테이블에서 자기 자신에게 조인
 . 하나의 테이블을 여러번 복사해서 조인
 . 자신이 가진 컬럼을 다양하게 변형시킬때 활용




=============================================


key
 . 검색, 정렬 시 tuple을 구분할 수 있는 기준이 되는 Attribute
1) 후보키 (candidate Key)
 . 튜플을 유일하게 식별하기 위해 사용하는 속성들
 . 유일성: key로 하나의 tuple을 식별해야됨
 . 최소성 : 꼭 필요한 속성으로만 구성
2) 기본키 (primary Key)
 . 후보키 중 선택한 메인키
 . Null값을 가질 수 없음
 . 동일한 값 중복 안됨
3) 대체키 (Alternate key)
 . 후보키 중 기본키를 제외한 나머지 키, 보조키
4) 슈퍼키 (super Key)
 . 유일성을 만족하지만 최소성은 없음
5) 외래키 (forgin Key)
 . 다른 릴레이션의 기본키를 참조




인덱스 ex) code_table
 . 데이터가 저장된 레코드의 주소
 . 데이터베이스에서 조회 및 검색을 더 빠르게 할 수 있는 방법
 . 추가나 삭제, 수정의 경우는 쿼리문 실행 속도 느림
 . 저장성능 희생하고 읽기 속도를 높임

- 동작
 . 자주 조회되는 Column 에 대한 Index Table을 따로 만듬
 . index table에서 where에 포함된 값 검색
 . 해당값의 table_id PK를 원본테이블에서 검색

- 프라이머리 인덱스
 . 클러스터드 : 비슷한 것들을 하나로 묶은 형태

- 세컨더리 인덱스


==========================================


B tree 인덱스 알고리즘
 . 노드에 자식노드 포인터가 저장되어 있음
 . 루트노드에서 어떤 리프노드에 이르는 한개의 경로만 검색
 . 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘

hash 인덱스 알고리즘
 . 동등연산에 특화된 자료구조



==========================================


ORM (Object Relational Mapping)
 . 객체와 관계형 DB의 데이터를 자동으로 매핑
- 영속성(persistance)
 . 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않음
- persistence layer
 . 프로그램의 아키텍처에서 직접 구현하지 않고 persistence framework를 이용한 개발이 많이 이뤄짐
 . 간단한 작업만으로 DB와 연동되는 시스템을 개발
 . presertation layer > business logic > persistence layer > DB

- 장점
 . 직관적이고 비즈니스 로직에 집중할수 있게 해줌
 . ORM은 독립적으로 작성됨, 재사용 및 유지보수 편리성 증가
 . DBMS에 대한 종속성이 줄어듬

- 단점
 . ORM으로만 완벽한 서비스를 구현하기 어려움

==========================================


Anomaly (이상)
 . 정규화를 해야하는 이유
 . 잘못된 테이블 설계로 Anomary(이상현상)이 나타남
1) 삽입이상
 . 삽입시 원하지 않은 데이터가 추가되는 현상 
 . 불필요한 데이터를 추가해야 삽입할 수 있는 상황
 ex) 사원정보가 기본키인데 null임
2) 갱신이상
 . 갱신시 일부 튜플의 정보만 갱신되는 현상
 . 일부만 변경하여 데이터가 불일치 하는 모순의 문제
 ex) 부서명만 바꾸고 부서코드 안바꿈
3) 삭제이상
 . 삭제시 원하지 않은 데이터가 함께 삭제되는 현상
 . 튜플삭제로 꼭 필요한 데이터까지 삭제됨


==========================================


 5) 데이터 베이스 언어 (DDL, DML, DCL, TCL) 

1) DDL (Data Definition Language)
 .  테이블과 같은 데이터 구조 정의하는 명령 (Create, alter, drop, ..)
2) DML (Data Manipulation Lang~)
 . 데이터 조회하거나 변형하는 명령 (select, insert, update, delete)
3) DCL (Data Control Lang~)
 . 데이터 베이스 접근 권한을 주거나 회수하는 명령 (grant revoke)
4) TCL (Transaction Control Lang)
 . 논리적 작업을 단위로 묶어 처리하기 위한 명령 (Commit, Rollback..)


==========================================



정규화 Normal Form (두부이걸다조)
 . 중복을 최소화하기 위해 데이터를 구조화하는 작업
 . DB 변경 시 이상현상 제거, DB구조의 안정성을 최대화

1) 제1정규형
 . 모든 도메인이 원자값
 . 모든 열과 행의 중복지점에는 한개의 값만 가짐

2) 제2정규형
 . 부분 함수적 종속 제거
 . 중복되는 컬럼끼리 별도 테이블 만들어서 중복 제거
 . 하나의 속성키로 기본키로 구성됨

3) 제3정규형
 . 이행적 함수 종속 제거
 ex) 주문번호 - 회원ID - 회원명 : 이행적 종속 발생
      > 주문번호 - 회원ID / 회원ID - 회원명 분리

4) BCNF (제3.5정규형) (여기까지가 중요)
 . 결정자이면서 후보키가 아닌것 제거
 . 모든 결정자는 후보키여야만 함

5) 제4정규형
 . 다치 종속 제거

6) 제5정규형
 . 조인 종속성 제거

===========================================


Redis
 . RAM에 저장해둠
 . 빠른 대응이 가능
 . 휘발성이므로 특정 구간에 스냅샷이나 주기적으로 반복

