네트워크

OSI 7 Layers (7계층)
 . 통신이 일어나는 과정을 단계별 확인
 . 특정한 곳에 이상이 생기면 해당 단계만 수정

1) Physucal (물리적)
 . 데이터 전기적 신호로 변환하여 주고받음
 . 데이터 전송 역할만 진행
 . LAN케이블, 허브, 리피터

2) DataLink (데이터링크)
 . 안전하게 전달되도록 하는 기능(에러검출, 재전송, 흐름제어)
 . MAC주소를 통해 통신
 . 브릿지, 스위치

3) Network (네트워크)
 . 데이터를 목적지까지 가장 빠르게 전달하는 기능
 . ip 주소 지정하고, 라우터로 이동할 경로 선택하고, 해당 경로로 패킷전달
 . 라우터, IP

4) Transport (전송)
 . 프로토콜을 통해 통신 활성화
 . 포트를 열어두고 프로그램들이 전송할 수 있도록
 . TCP(신뢰성, 연결지향적) / UDP(실시간)

5) session (세션)
 . 데이터가 통신하기 위한 논리적 연결
 . TCP/IP 세션을 만들고 없앰
 . API, Socket

6) Presentation (표현)
 . 데이터 독립성 및 암호화
 . 파일 인코딩, 명령어 포장, 암호화
 . JPEG, MPEG

7) Application (응용)
 . 응용 프로세스와 직접 관계하여 서비스 수행
 . 사용자 인터페이스, 데이터베이스 관리 등
 . HTTP, FTP, DNS



==================================

TCP 양방향 통신
 . syn: 연결하는 플래그, fin: 연결종료하는 플래그
- 3 way handshake (연결성립)
 . 통신하기 전 논리적인 접속을 성립하는 과정
1) 클라이언트 > 서버 : sync 보냄 (x)
2) 서버 > 클라이언트 : 서버가 sync 받고, 클라이언트에게 받았다는 신호 보냄 (y, x+1)
3) 클라이언트 > 서버 : 서버응답의 패킷을 받고, 회신보냄 (y+1)

- 데이터 전송 방식
1) 클라이언트 > 서버 : packit 보냄
2) 서버 : 클라이언트 : ACK 보냄

- 4 way handshake (연결해제)
 . 연결 성립 후 통신 끝나면 해제하는 절차
1) 클라이언트 > 서버 : 연결종료한다는 FIN 플래그 보냄
2) 서버 > 클라이언트 : 서버 FIN받고, 받았다는 ACK신호 보냄, close wait 상태
3) 서버 > 클라이언트 : 연결 종료했다는 FIN플래그 보냄
4) 클라이언트 > 서버 : 클라이언트는 FIN받고, 받았다는 ACK신호 보냄, time wait상태
 . 서버는 ACK받은 후 소켓닫음
 . 클라이언트도 TIME_WAIT 시간이 끝나면 닫음

TCP통신 (Transmission Control Protocol)
 . 전송의 신뢰성은 보장하지만 (분실,중복,순서바뀜 자동으로 보정)
 . 매번 connection 연결해서 시간손실 발생
 . 패킷을 조금만 손실해도 재전송

- 흐름제어
 . 송신측과 수신측의 데이터 처리 속도 차이 해결
 . 수신측(receiver)이 패킷을 지나치게 많이 받지 않도록 송신측 데이터 전송량 조절
 . 수신측이 자신의 상태를 sender에게 피드백 (매번 패킷확인 응답을 받아야 다음패킷 전송)

- 혼잡제어
 . 송신측 데이터 전달과 네트워크 데이터 처리 속도차이 해결
 . 한 라우터에 데이터가 몰릴 경우, 모두 처리할 수 없음 > 오버플로우 발생



===========================================


UDP (user datagram protocol)
 . 비연결형 프로토콜
 . 데이터의 신속성
 . 실시간 방송, 온라인 게임
 . 손상된 세그먼트 수신에 대해 재전송 안함(네트워크 안좋을때 끊기는 현상)

- UDP header
 . 시작포트 - 도착지 포트 - 길이 - 오류검출

- DNS에서 UDP사용
 . request 양이 작음
 . 3 way handshaking으로 연결할 필요 없음
 . DNS 포트 : 53'




===========================================




대칭키
 . 암호화, 복호화 같은 암호키를 사용하는 알고리즘
 . 동일한 키를 주고 받아서 빠름
 . 해킹 위험 노출

공개키
 . 암호화, 복호화 사용하는 암호키를 분리
 . 자신의 고유키로만 복호화 할 수 있는 암호키를 공개함

SSL
 . 대칭키를 주고받을때만 공개키 암호화 방식 사용
 . 이후엔 계속 대칭키 암호화 방식 통신




===========================================



HTTP
 . 인터넷 상에서 클라이언트와 서버가 지원을 주고받을때 쓰는 통신규약
 . HTTP는 평문통신, 누군가 신호 가로채면 노출 이슈
 . 통신 상대를 확인하지 않음
 . 완전성 증명안하여 변조가능
 . 80번 포트

HTTPS
 . 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 주고받음
 . 암호화 통신은 CPU나 메모리 등 리소스 요구
 . 443 포트

- 단점
 . 암호화를 하는 과정이 웹 서버에 부하를 준다.
 . HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다.
 . HTTP에 비해 느리다.
 . 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다.

- 공개키 알고리즘 방식
 . 클라이언트 -> 서버
1) 사용자의 데이터를 공개키로 암호화 (공개키를 얻은 인증된 사용자)
2) 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화할 수 없음)
3) 서버의 개인키를 통해 복호화하여 요청 처리



===========================================



GET
 . 데이터가 Header부분에 url이 담겨 전송
 . url에 담기므로 크기가 제한적
 . 데이터가 그대로 노출
 . 서버에서 데이터를 가져와서 보여주는 용도

POST
 . 데이터가 body에 담겨 전송
 . 서버의 값이나 상태를 변경하는 용도





===========================================



로드밸런싱
 . 여러 서버에 트래픽을 분산시켜주는 것
 . 무중단 서비스 제공 가능

- 서버 선택 방식
 . 라운드 로빈 : CPU 스케줄링 방식
 . Weighted round robin (WRR) : 각 웹 서버에 가중치 부여하여 분산비율 산정
 . Least Connections : 연결 수가 가장 적은 서버 선택
 . Source : 사용자 IP대역을 해싱하여 분배 (특정 사용자 항상 같은 서버 접속)




===========================================



크롬창에 url 검색하면?
1) 브라우저 : http request 메세지 만든 후 웹서버 전송
2) OS에 의뢰하여 ip를 DNS에서 조회 (DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청)
3) 웹 서버와 TCP 연결 시도 (3way-handshaking)
4) 프로토콜 스택, LAN 어댑터 : 메세지를 패킷에 저장 후 수신처 주소 등 제어정보 덧붙임
5) 전기신호로 변환 후 신호를 LAN 케이블로 송출
6) 허브, 스위치, 라우터
7) 엑세스 회선 : 목적지까지 이동
8) 방화벽, 캐시서버 : 패킷검사 후 캐시서버에 있는지 확인, 없으면 웹서버 의뢰
9) 웹서버 : 프로토콜 스택 패킷 추출 후 메세지 복원하고 애플리케이션에 넘김
10) 다시 클라이언트에 전송(동일 프로세스)



===========================================


쿠키
 . 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.
 . 이름, 값, 유효 시간, 경로 등을 포함하고 있다.
 . 클라이언트의 상태 정보를 브라우저에 저장하여 참조한다.

세션
 . 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
 . 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

쿠키와 세션의 차이점
 . 저장 위치
  쿠키 : 클라이언트
  세션 : 서버
 . 보안
  쿠키 : 클라이언트에 저장되므로 보안에 취약하다.
  세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다.
 . 라이프사이클
  쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다.
  세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
 . 속도
  쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠르다.
  세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다.
